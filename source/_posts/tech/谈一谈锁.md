---
title: 谈一谈锁
date: 2017-05-02 21:05
categories: technology
tags:
- linux
- programming
---

## 锁有什么用
锁是进行多线程同步的一种重要方式。从本质上来讲，锁是一种对资源分配的控制，只有持有锁的线程才能够访问被锁住的资源，这样就实现了线程安全。

## 实现方式

一个很朴素的想法是通过一个标志位来判断某资源正在被使用
```c
int flag;

void func(){
    if(flag==1){ // if free
        flag=0; // aquire lock
        critical_section
        flag=1; // release lock
    }
}
```

但是这样的代码有一个问题，由于判断(`if(flag)==1`)和赋值(`flag=0`)分为两个步骤执行，不具有原子性。

设想这样的情况：  
线程a判断flag==1后，系统进行线程切换，线程a暂停而线程b运行，这时线程b看到的标志位flag依然等于1，因此进程a和进程b将同时进入临界区而导致错误。

这一问题通过CAS(Compare and Swap)可以解决。CAS能够原子性地完成Compare&Swap这两个操作，因此就不会出现判断之后赋值之前系统进行线程切换导致错误。

## 各种类型的锁

针对不同的应用场景，应该使用不同类型的锁。

### 原子锁

原子锁其实不是一种锁，而是指原子操作，比如之前提到的CAS操作。一般系统都提供了针对整数和针对位操作的一套原子操作。由于原子操作具有原子性，因此无需额外加锁也可以保证操作不被线程切换所打断。

### 自旋锁

自旋锁是一种轻量级的同步方案，当自旋锁lock被阻塞时，进行死循环CPU空转等待其他线程释放锁。

自旋锁适用于线程执行时间较短的场景，由于使用自旋锁不需要睡眠和唤醒等过程，因此在这种场景下使用自旋锁的效率很高。

### 序列锁(Seqlock)

序列锁提供了读写的优先级。Seqlock 实现原理是依赖一个序列计数器，当写者写入数据时，会得到一把锁，并且将序列值加 1。当读者读取数据之前和之后，该序列号都会被读取，如果读取的序列号值都相同，则表明写没有发生。反之，表明发生过写事件，则放弃已进行的操作，重新循环一次，直至成功。

这样序列锁中的写者不用等待，适用于Write Rarely Read Mostly的场景。

**序列锁的原理很像数据库中基于timestamp的乐观锁。**

### 重量级锁

重量级锁比如mutex，会把线程投入睡眠，因此很适合线程执行时间较长，处理任务繁重的场景。

## 其他
从Java synchronized锁的升级也可以看出，首先使用偏向锁，也就是类似于自旋锁，然后是轻量级锁，最后升级为重量级锁。